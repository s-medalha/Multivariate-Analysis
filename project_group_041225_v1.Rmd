---
title: "Multivariate Analysis"
author:
  - Ana Rasinhas
  - Daniela Gonçalves
  - Pedro Fernandes
  - Ricardo Branco
  - Samuel Medalha
date: last-modified
format:
  pdf: default
execute:
  echo: false
editor_options: 
  chunk_output_type: inline
---

```{r}
#| label: load-packages
#| include: false

library(tidyverse)
library(readxl)
library(psych)
library(cluster)
library(factoextra)
library(dendextend)
library(ggrepel)
library(cluster)
library(factoextra)
```


```{r}
#| label: import-data
#| include: false
#| warnings: false

raw_data <- read.csv("C:/Users/ricardo.branco/Downloads/ESS11e04_0.csv")

```

```{r}
#| label: data-processing
#| include: false
#| warnings: false

selected_vars <- c("cntry", "trstprl", "trstlgl", "trstplt", "trstprt", "trstep", "trstun", "stfeco", "stfgov", "stfdem", "stfedu", "stfhlth", "imbgeco", "imueclt", "imwbcnt", "imsmetn", "imdfetn", "impcntr", "eqwrkbg", "eqpolbg", "eqmgmbg", "eqpaybg", "eqparep", "eqparlv", "freinsw", "fineqpy")

selected_vars1 <- c("trstprl", "trstlgl", "trstplc", "trstplt", "trstprt", "trstep", "trstun", "stfeco", "stfgov", "stfdem", "stfedu", "stfhlth", "imbgeco", "imueclt", "imwbcnt")

reduced_scale_vars <- c("imsmetn", "imdfetn", "impcntr", "eqwrkbg", "eqpolbg", "eqmgmbg", "eqmgmbg", "eqpaybg", "eqparep", "eqparlv", "freinsw", "fineqpy")

inverted_vars <- c("imsmetn", "imdfetn", "impcntr", "eqparep", "eqparlv", "freinsw", "fineqpy")

removed_vars <- c("stfeco", "stfgov", "stfdem", "stfedu", "stfhlth", "eqparep", "eqparlv", "freinsw", "fineqpy")

removed_countries <- c("IS", "IL", "ME", "NO", "RS", "CH", "UA", "GB")

data <- raw_data |> 
  select(all_of(selected_vars)) |> # select only some variables
  filter(!cntry %in% removed_countries) |>  # remove non-EU countries
  mutate(across(all_of(selected_vars), ~if_else(. %in% c(77, 88, 99), NA, .))) |> # set to NA when answer is unknown
  mutate(across(all_of(reduced_scale_vars), ~if_else(. %in% c(7,8,9), NA, .))) |> # set to NA when answer is unknown
  na.omit() |> # omit missing values
  mutate(imsmetn = 5 - imsmetn, 
         imdfetn = 5 - imdfetn,
         impcntr = 5 - impcntr,
         eqparep = 6 - eqparep,
         eqparlv = 6 - eqparlv,
         freinsw = 6 - freinsw,
         fineqpy = 6 - fineqpy) |> # invert scale of some variables
  select(-all_of(removed_vars))

scaled_data <- data |> 
  select(-cntry) |> 
  scale() |> 
  as_tibble()

data |> count(cntry)
```


## Abstract

## Introduction

## Methodology
```{r}
#| label: KMO
#| warning: false
KMO(scaled_data)
```
After executing the Kaiser-Meyer-Olkin test, the MSA (measure of sampling accuracy, which varies between 0 and 1) is calculated as `r format(KMO(scaled_data)$MSA, digits = 2)`. This is classified as "meritorious", so we have an indication that factor analysis is suitable for this data set.

We'll start by performing factor analysis with a high number of values:
  
```{r}
#| label: first_fa
#| warning: false
round(principal(scaled_data, nfactors = length(scaled_data))$Vaccounted, digits = 3)
round(fa(scaled_data, nfactors = length(scaled_data))$Vaccounted, digits = 3)
```

```{r}
#| label: scree_plot
scree(scaled_data, factors = FALSE)
```


```{r}
pcf_varimax <- principal(scaled_data, nfactors = 3, method = "cov", rotate = "varimax", scores = TRUE ) # cov? or cor?
pcf_quartimax <- principal(scaled_data, nfactors = 3, method = "cov", rotate = "quartimax")
paf_varimax <- fa(scaled_data, nfactors = 3, rotate = "varimax")
paf_quartimax <- fa(scaled_data, nfactors = 3, rotate = "quartimax")
print(pcf_varimax$loadings, cutoff = 0.6, digits = 3)
print(pcf_quartimax$loadings, cutoff = 0.6, digits = 3)
print(paf_varimax$loadings, cutoff = 0.6, digits = 3)
print(paf_quartimax$loadings, cutoff = 0.6, digits = 3)
```
Explicar porque standardizamos a média das observaçoes para cada país .


```{r}
data_scores2 <- cbind(data["cntry"], pcf_varimax$scores)

country_means2 <- data_scores2  %>% 
  group_by(cntry)  %>% 
  summarise(across(starts_with("RC"), mean))  %>%  
  rename("country" = cntry, "trust" = RC2, "immigration" = RC1, "equality" = RC3)  %>% 
  column_to_rownames("country") %>% 
  scale() %>%
  as.data.frame()

#new features like country labels and sample size
country_means2$country <- rownames(country_means2)

sample_size <- data %>%
  count(cntry, name = "n") %>% 
  rename(country = cntry)

country_means2 <- country_means2 %>%
  left_join(sample_size, by = "country")

```



```{r}
my_theme <- function(base_size = 12) {
  theme_minimal(base_size = base_size) +
    theme(
      # Customizing the title and subtitle
      plot.title = element_text(face = "bold", size = 14, margin = margin(b = 10)),
      plot.subtitle = element_text(size = 11, color = "gray30", margin = margin(b = 15)),
      # Grid line cleanup
      panel.grid.minor = element_blank(),
      panel.grid.major = element_line(linetype = "dotted", color = "gray85"),
      # Axis line customization
      axis.line = element_line(color = "gray80"),
      # Legend position
      legend.position = "bottom",
      # Caption formatting
      plot.caption = element_text(hjust = 0, color = "gray50", size = 9, margin = margin(t = 15)),
      # Panel background and spacing
      panel.background = element_rect(fill = "white", color = NA),
      plot.background = element_rect(fill = "white", color = NA)
    )
}

```

```{r}
#faceting 1

pairs_df <- country_means2 %>%
  mutate(id = row_number()) %>%
  crossing(
    tibble(var1 = c("equality", "equality", "immigration"),
           var2 = c("immigration", "trust", "trust"))
  ) %>%
  mutate(
    value1 = case_when(
      var1 == "equality" ~ equality,
      var1 == "immigration" ~ immigration,
      var1 == "trust" ~ trust
    ),
    value2 = case_when(
      var2 == "equality" ~ equality,
      var2 == "immigration" ~ immigration,
      var2 == "trust" ~ trust
    )
  ) %>%
  select(id, country, var1, var2, value1, value2)

pairs_df <- pairs_df %>%
  mutate(pair = paste(var1, "vs", var2))

facet_plot <- ggplot(pairs_df, aes(x = value1, y = value2, color = pair)) +
  
  geom_hline(data = reference_lines, aes(yintercept = h_intercept),
             linetype = "dashed", color = "gray50", alpha = 0.5) +
  geom_vline(data = reference_lines, aes(xintercept = v_intercept),
             linetype = "dashed", color = "gray50", alpha = 0.5) +
  geom_point(size = 3, alpha = 0.7) +
  geom_text_repel(aes(label = country), size = 3.5, show.legend = FALSE) +
  facet_wrap(~ pair) +
  coord_equal() +
  scale_color_manual(values = c(  # Add 'values ='
    "equality vs immigration" = "#E69F00",
    "equality vs trust" = "#009E73",
    "immigration vs trust" = "#0072B2"
  ))+
  
  labs(
    title = "Pairwise Country Comparisons Across Dimensions",
    x = NULL,
    y = NULL
  ) +
  
  my_theme() +
  theme(legend.position = "none")

print(facet_plot)
```





CLUSTER ANALYSIS STARTS HERE!!!

```{r}
# 1. Prepare data (select only numeric variables for clustering)
cluster_data <- country_means2[, c("trust", "immigration", "equality")]
rownames(cluster_data) <- country_means2$country

# 2. Hierarchical methods to determine number of clusters

# Ward method
hc_ward <- agnes(cluster_data, metric = "euclidean", method = "ward")

# Average method
hc_average <- agnes(cluster_data, metric = "euclidean", method = "average")

# Complete method
hc_complete <- agnes(cluster_data, metric = "euclidean", method = "complete")

# Single method
hc_single <- agnes(cluster_data, metric = "euclidean", method = "single")


print(hc_ward$ac)
print(hc_average$ac)
print(hc_complete$ac)
print(hc_single$ac)


plot(
  hc_ward,
  which.plots = 2,
  main = "Dendrogram - Ward Method",
  hang = -1,
  cex = 0.8
)

fviz_nbclust(cluster_data, kmeans, method = "wss")

fviz_nbclust(cluster_data, kmeans, method = "silhouette")
```

```{r}
#Random k-means
set.seed(123) #for replicability

kmeans_result <- kmeans(cluster_data, centers = 5, nstart = 25, iter.max = 100) # nstart = different initial positions; 

print(kmeans_result)

country_clusters <- country_means2
country_clusters$cluster <- as.factor(kmeans_result$cluster)

```

```{r}
#deterministic k-means using hierarchical method

hcward <- agnes(cluster_data, method = "ward")

groups_hcward <- cutree(as.hclust(hcward),k = 5) #cut the tree into 5 clusters

#compute deterministic initial centroids
initial_centers <- aggregate(cluster_data, by = list(groups_hcward), FUN = mean)

initial_centers <- initial_centers[ ,-1] # remove group label column

#compute k-meanins
kmeans_result_d <- kmeans(cluster_data, centers = initial_centers, iter.max = 100)

#merge to data
country_clusters_d <- country_means2
country_clusters_d$cluster <- as.factor(kmeans_result_d$cluster)

print(kmeans_result_d$centers)
print(table(country_clusters_d$cluster))
```

```{r}
#Compare methods random vs deterministic

# Compare cluster assignments
comparison <- data.frame(
  country = rownames(cluster_data),
  hierarchical_kmeans = kmeans_result_d$cluster,
  random_kmeans = kmeans_result$cluster
) %>% 
  arrange(hierarchical_kmeans, random_kmeans)

# Check agreement
print(comparison)

# Within-cluster sum of squares (lower is better)
cat("Deterministic total WSS:", kmeans_result_d$tot.withinss, "\n")
cat("Random total WSS:", kmeans_result$tot.withinss, "\n")


```




```{r}
#Prepare data for visualization
#1.color uniformity
cluster_colors <- c(
  "1" = "#E69F00",
  "2" = "#0072B2",
  "3" = "#009E73",
  "4" = "#D55E00",
  "5" = "#CC79A7"
)

```

```{r}
#faceting 2

pairs_df2 <- country_clusters_d %>%
  mutate(id = row_number()) %>%
  crossing(
    tibble(var1 = c("equality", "equality", "immigration"),
           var2 = c("immigration", "trust", "trust"))
  ) %>%
  mutate(
    value1 = case_when(
      var1 == "equality" ~ equality,
      var1 == "immigration" ~ immigration,
      var1 == "trust" ~ trust
    ),
    value2 = case_when(
      var2 == "equality" ~ equality,
      var2 == "immigration" ~ immigration,
      var2 == "trust" ~ trust
    )
  ) %>%
  select(id, country, cluster, var1, var2, value1, value2)

facet_plot_2 <- ggplot(pairs_df2, 
                     aes(x = value1, y = value2, color = cluster)) +
  
  geom_hline(yintercept = mean(country_means$trust),
             linetype = "dashed", color = "gray50", alpha = 0.5) +
  geom_vline(xintercept = mean(country_means$equality),
             linetype = "dashed", color = "gray50", alpha = 0.5) +

  geom_point(size = 3, alpha = 0.7) +
  geom_text_repel(aes(label = country, color = cluster), size = 3) +

  facet_wrap(~ paste(var1, "vs", var2)) +
  coord_equal()+
  scale_color_manual(values = cluster_colors) +
  
  labs(
    title = "Pairwise Country Comparisons Across Dimensions",
    x = NULL,
    y = NULL,
    color = "Cluster"
  ) +
  
  my_theme()

print(facet_plot_2)

```




```{r}
# Define Lookup and Cluster Data ---

# Revised lookup table with all 22 countries
country_lookup <- data.frame(
  country = c("AT", "BE", "BG", "CY", "DE", "EE", "ES", "FI", "FR", "GR", "HR", "HU", "IE", "IT", "LT", "LV", "NL", "PL", "PT", "SE", "SI", "SK"),
  map_region = c("Austria", "Belgium", "Bulgaria", "Cyprus", "Germany", "Estonia", "Spain", "Finland", "France", "Greece", "Croatia", "Hungary", "Ireland", "Italy", "Lithuania", "Latvia", "Netherlands", "Poland", "Portugal", "Sweden", "Slovenia", "Slovakia")
)


# Data Merging and Preparation ---

# Get Europe map data
europe_map <- map_data("world")

# Merge your data with the lookup
country_clusters_full <- merge(country_clusters_d, country_lookup, by = "country")

# Merge with map data
europe_map <- merge(europe_map, country_clusters_full, by.x = "region", by.y = "map_region", all.x = TRUE)

# Filter to only show countries in your dataset
europe_map <- europe_map %>% filter(region %in% country_lookup$map_region)

europe_map <- europe_map %>%
  dplyr::arrange(group, order, long)

# Create the Map ---

ggplot(europe_map, aes(x = long, y = lat, group = group, fill = cluster)) +
  geom_polygon(color = "light grey", linewidth = 0.25) +
  scale_fill_manual(values = cluster_colors, name = "Clusters", na.value = "lightgray") +
  # Adjusted limits to better frame the entire region
  coord_fixed(1.3, xlim = c(-15, 35), ylim = c(32, 72)) +
  theme_void() +
  labs(title = "European Countries by Cluster", subtitle = "Based on trust, immigration, and equality attitudes") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold", margin = margin(b = 5)),
    plot.subtitle = element_text(hjust = 0.5, size = 11, margin = margin(b = 15)),
    legend.position = "bottom",
    legend.title = element_text(size = 10, face = "bold"),
    legend.text = element_text(size = 9)
  )
```



## Results

## Discussion

## Conclusions

## References
