---
title: "Multivariate Analysis"
author:
  - Ana Rasinhas
  - Daniela Gonçalves
  - Pedro Fernandes
  - Ricardo Branco
  - Samuel Medalha
date: last-modified
format:
  typst: default
execute:
  echo: false
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: load-packages
#| include: false

library(tidyverse)
library(readxl)
library(psych)
library(cluster)
library(factoextra)
library(dendextend)
library(ggrepel)
```


```{r}
#| label: import-data
#| include: false
#| warnings: false

raw_data <- read_excel("./dataset2.xlsx", range = cell_cols("A:YT"), sheet = 1)

```

```{r}
#| label: data-processing
#| include: false
#| warnings: false

selected_vars <- c("cntry", "trstprl", "trstlgl", "trstplt", "trstprt", "trstep", "trstun", "stfeco", "stfgov", "stfdem", "stfedu", "stfhlth", "imbgeco", "imueclt", "imwbcnt", "imsmetn", "imdfetn", "impcntr", "eqwrkbg", "eqpolbg", "eqmgmbg", "eqpaybg", "eqparep", "eqparlv", "freinsw", "fineqpy")

selected_vars1 <- c("trstprl", "trstlgl", "trstplc", "trstplt", "trstprt", "trstep", "trstun", "stfeco", "stfgov", "stfdem", "stfedu", "stfhlth", "imbgeco", "imueclt", "imwbcnt")

reduced_scale_vars <- c("imsmetn", "imdfetn", "impcntr", "eqwrkbg", "eqpolbg", "eqmgmbg", "eqmgmbg", "eqpaybg", "eqparep", "eqparlv", "freinsw", "fineqpy")

inverted_vars <- c("imsmetn", "imdfetn", "impcntr", "eqparep", "eqparlv", "freinsw", "fineqpy")

removed_vars <- c("stfeco", "stfgov", "stfdem", "stfedu", "stfhlth", "eqparep", "eqparlv", "freinsw", "fineqpy")

removed_countries <- c("IS", "IL", "ME", "NO", "RS", "CH", "UA", "GB")

data <- raw_data |> 
  select(all_of(selected_vars)) |> # select only some variables
  filter(!cntry %in% removed_countries) |>  # remove non-EU countries
  mutate(across(all_of(selected_vars), ~if_else(. %in% c(77, 88, 99), NA, .))) |> # set to NA when answer is unknown
  mutate(across(all_of(reduced_scale_vars), ~if_else(. %in% c(7,8,9), NA, .))) |> # set to NA when answer is unknown
  na.omit() |> # omit missing values
  mutate(imsmetn = 5 - imsmetn, 
         imdfetn = 5 - imdfetn,
         impcntr = 5 - impcntr,
         eqparep = 6 - eqparep,
         eqparlv = 6 - eqparlv,
         freinsw = 6 - freinsw,
         fineqpy = 6 - fineqpy) |> # invert scale of some variables
  select(-all_of(removed_vars))

scaled_data <- data |> 
  select(-cntry) |> 
  scale() |> 
  as_tibble()

```


## Abstract

## Introduction

## Methodology
```{r}
#| label: KMO
#| warning: false
KMO(scaled_data)
```
After executing the Kaiser-Meyer-Olkin test, the MSA (measure of sampling accuracy, which varies between 0 and 1) is calculated as `r format(KMO(scaled_data)$MSA, digits = 2)`. This is classified as "meritorious", so we have an indication that factor analysis is suitable for this data set.

We'll start by performing factor analysis with a high number of values:
  
```{r}
#| label: first-fa
#| warning: false
round(principal(scaled_data, nfactors = length(scaled_data))$Vaccounted, digits = 3)
round(fa(scaled_data, nfactors = length(scaled_data))$Vaccounted, digits = 3)
```

```{r}
#| label: scree-plot
scree(scaled_data, factors = FALSE)
```


```{r}
#| label: second-fa
#| warning: false

pcf_varimax <- principal(scaled_data, nfactors = 3, rotate = "varimax", scores = TRUE)
pcf_quartimax <- principal(scaled_data, nfactors = 3, rotate = "quartimax")
paf_varimax <- fa(scaled_data, nfactors = 3, rotate = "varimax")
paf_quartimax <- fa(scaled_data, nfactors = 3, rotate = "quartimax")
print(pcf_varimax$loadings, cutoff = 0.6, digits = 3)
print(pcf_quartimax$loadings, cutoff = 0.6, digits = 3)
print(paf_varimax$loadings, cutoff = 0.6, digits = 3)
print(paf_quartimax$loadings, cutoff = 0.6, digits = 3)
```
Explicar porque standardizamos a média das observaçoes para cada país .


```{r}
#| label: country-means
data_scores <- cbind(data["cntry"], scale(pcf_varimax$scores))

country_means <- data_scores |>
  group_by(cntry) |>
  summarise(across(starts_with("RC"), mean)) |> 
  rename("country" = cntry, "trust" = RC2, "immigration" = RC1, "equality" = RC3)
  
ggplot(country_means, aes(x=equality, y=immigration)) +
  geom_point(alpha = 0.7) + 
  labs (x = "Support for gender equality", y = "Support for immigration") +
  theme_minimal()

ggplot(country_means, aes(x = trust, y = immigration)) +
  geom_point(alpha = 0.7) + 
  labs (x = "Trust in institutions", y = "Support for immigration") +
  theme_minimal()

ggplot(country_means, aes(x = equality, y = trust)) +
  geom_point(alpha = 0.7) + 
  labs(x = "Support for gender equality", y = "Trust in institutions") +
  theme_minimal()
```





```{r}
#| label: R-squared-function
#| include: false

numeric_data <- country_means[ , -1, drop = FALSE]

numeric_data <- scale(numeric_data)

RSquared <- function(distance, method, k){
  # Get vector with mean of each variable
  centroid <- colMeans(numeric_data)
  # Get total SS
  SSt <- sum(apply(numeric_data, 1, function(row) sum((row - centroid)^2)))
  # Get distance matrix
  dist_matrix <- dist(numeric_data, method = distance)
  # Hierarchical clustering
  hc <- hclust(dist_matrix, method = method)
  # Cut dendrogram with k clusters
  cut <- cutree(hc, k = k)
  SSw <- 0
  for(i in 1:k) {
    # Get indices of countries in cluster i
    cluster_indices <- which(cut == i)
    
    if(length(cluster_indices) > 0) {
      # Get data for this cluster
      cluster_data <- numeric_data[cluster_indices, , drop = FALSE]
      
      # Calculate cluster mean
      cluster_mean <- colMeans(cluster_data)
      
      # Weighted squared distance from cluster centroid
      SSw <- SSw + sum(apply(cluster_data, 1, function(row) 
      sum((row - cluster_mean)^2)))
    }
  }
  1-(SSw/SSt)
}

```

```{r}
#| label: R-squared-plot

methods <- c("ward.D", "average", "complete", "single")

plot_data <- do.call(rbind, lapply(methods, function(method) {
  data.frame(
    k = 1:10,
    R_squared = sapply(1:10, function(k) {
      RSquared("euclidean", method, k)
    }),
    Method = method
  )
}))

  ggplot(plot_data, aes(x = k, y = R_squared, color = Method)) +
    geom_line(size = 0.5) +
    geom_point(size = 1) +
    coord_cartesian(ylim = c(0, 1)) +
    scale_x_continuous(breaks = k_values) +
    scale_y_continuous(breaks = (0:10)/10) +
    labs(title = "Comparison of different hierarchical clustering methods", x = "Number of clusters", y = "R-squared")

```

```{r}
#| label: hierarchical-cluster-analysis
#| warning: false

euclidean_dist <- dist(numeric_data, method = "euclidean")

hc_ward <- hclust(euclidean_dist, method = "ward.D")
hc_average <- hclust(euclidean_dist, method = "average")
hc_complete <- hclust(euclidean_dist,  method = "complete")
hc_single <- hclust(euclidean_dist, method = "single")


fviz_dend(hc_ward)
```

```{r}
#| label: random-kmeans

set.seed(123) #for replicability

random_kmeans <- kmeans(numeric_data, centers = 5, nstart = 25, iter.max = 100) # nstart = different initial positions; 

  ggplot(country_means, aes(trust, immigration, color = factor(random_kmeans$cluster), label = country)) +
    geom_text() + 
    theme_minimal()

  ggplot(country_means, aes(trust, equality, color = factor(random_kmeans$cluster), label = country)) +
    geom_text() + 
    theme_minimal()


```

```{r}
#| label: deterministic-kmeans

#deterministic k-means using hierarchical method

groups_hcward <- cutree(hc_ward, k = 5) #cut the tree into 5 clusters

#compute deterministic initial centroids
initial_centers <- aggregate(numeric_data, by = list(groups_hcward), FUN = mean)[-1]

#compute k-means
seeded_kmeans <- kmeans(numeric_data, centers = initial_centers, iter.max = 100)

ggplot(country_means, aes(trust, immigration, color = factor(seeded_kmeans$cluster), label = country)) +
    geom_text() + 
    theme_minimal()

  ggplot(country_means, aes(trust, equality, color = factor(seeded_kmeans$cluster), label = country)) +
    geom_text() + 
    theme_minimal()
  
cat("Deterministic total WSS:", seeded_kmeans$tot.withinss, "\n")
cat("Random total WSS:", random_kmeans$tot.withinss, "\n")

```


```{r}
#| label: europe-map
#Prepare data for visualization
#1.color uniformity
cluster_colors <- c(
  "1" = "#E69F00",
  "2" = "#0072B2",
  "3" = "#009E73",
  "4" = "#D55E00",
  "5" = "#CC79A7"
)

country_clusters_d <- cbind(numeric_data, country_means[1])
country_clusters_d$cluster <- as.factor(random_kmeans$cluster)

my_theme <- function(base_size = 12) {
  theme_minimal(base_size = base_size) +
    theme(
      # Customizing the title and subtitle
      plot.title = element_text(face = "bold", size = 14, margin = margin(b = 10)),
      plot.subtitle = element_text(size = 11, color = "gray30", margin = margin(b = 15)),
      # Grid line cleanup
      panel.grid.minor = element_blank(),
      panel.grid.major = element_line(linetype = "dotted", color = "gray85"),
      # Axis line customization
      axis.line = element_line(color = "gray80"),
      # Legend position
      legend.position = "bottom",
      # Caption formatting
      plot.caption = element_text(hjust = 0, color = "gray50", size = 9, margin = margin(t = 15)),
      # Panel background and spacing
      panel.background = element_rect(fill = "white", color = NA),
      plot.background = element_rect(fill = "white", color = NA)
    )
}


#faceting 2

pairs_df2 <- country_clusters_d %>%
  mutate(id = row_number()) %>%
  crossing(
    tibble(var1 = c("equality", "equality", "immigration"),
           var2 = c("immigration", "trust", "trust"))
  ) %>%
  mutate(
    value1 = case_when(
      var1 == "equality" ~ equality,
      var1 == "immigration" ~ immigration,
      var1 == "trust" ~ trust
    ),
    value2 = case_when(
      var2 == "equality" ~ equality,
      var2 == "immigration" ~ immigration,
      var2 == "trust" ~ trust
    )
  ) %>%
  select(id, country, cluster, var1, var2, value1, value2)

facet_plot_2 <- ggplot(pairs_df2, 
                     aes(x = value1, y = value2, color = cluster)) +
  
  geom_hline(yintercept = mean(country_means$trust),
             linetype = "dashed", color = "gray50", alpha = 0.5) +
  geom_vline(xintercept = mean(country_means$equality),
             linetype = "dashed", color = "gray50", alpha = 0.5) +

  geom_point(size = 3, alpha = 0.7) +
  geom_text_repel(aes(label = country, color = cluster), size = 3) +

  facet_wrap(~ paste(var1, "vs", var2)) +
  coord_equal()+
  scale_color_manual(values = cluster_colors) +
  
  labs(
    title = "Pairwise Country Comparisons Across Dimensions",
    x = NULL,
    y = NULL,
    color = "Cluster"
  ) +
  
  my_theme()

print(facet_plot_2)


# Define Lookup and Cluster Data ---

# Revised lookup table with all 22 countries
country_lookup <- data.frame(
  country = c("AT", "BE", "BG", "CY", "DE", "EE", "ES", "FI", "FR", "GR", "HR", "HU", "IE", "IT", "LT", "LV", "NL", "PL", "PT", "SE", "SI", "SK"),
  map_region = c("Austria", "Belgium", "Bulgaria", "Cyprus", "Germany", "Estonia", "Spain", "Finland", "France", "Greece", "Croatia", "Hungary", "Ireland", "Italy", "Lithuania", "Latvia", "Netherlands", "Poland", "Portugal", "Sweden", "Slovenia", "Slovakia")
)


# Data Merging and Preparation ---

# Get Europe map data
europe_map <- map_data("world")

# Merge your data with the lookup
country_clusters_full <- merge(country_clusters_d, country_lookup, by = "country")

# Merge with map data
europe_map <- merge(europe_map, country_clusters_full, by.x = "region", by.y = "map_region", all.x = TRUE)

# Filter to only show countries in your dataset
europe_map <- europe_map %>% filter(region %in% country_lookup$map_region)

europe_map <- europe_map %>%
  dplyr::arrange(group, order, long)

# Create the Map ---

ggplot(europe_map, aes(x = long, y = lat, group = group, fill = cluster)) +
  geom_polygon(color = "light grey", linewidth = 0.25) +
  scale_fill_manual(values = cluster_colors, name = "Clusters", na.value = "lightgray") +
  # Adjusted limits to better frame the entire region
  coord_fixed(1.3, xlim = c(-15, 35), ylim = c(32, 72)) +
  theme_void() +
  labs(title = "European Countries by Cluster", subtitle = "Based on trust, immigration, and equality attitudes") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold", margin = margin(b = 5)),
    plot.subtitle = element_text(hjust = 0.5, size = 11, margin = margin(b = 15)),
    legend.position = "bottom",
    legend.title = element_text(size = 10, face = "bold"),
    legend.text = element_text(size = 9)
  )
```
Ver várias métricas?



## Results

## Discussion

## Conclusions

## References